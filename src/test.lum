class Kind {
    left_paren { return 0 }
    right_paren { return 1 }
    left_bracket { return 2 }
    right_bracket { return 3 }
    left_brace { return 4 }
    right_brace { return 5 }
    less { return 6 }
    greater { return 7 }
    equal { return 8 }
    plus { return 9 }
    minus { return 10 }
    slash { return 11 }
    star { return 12 }
    dot { return 13 }
    comma { return 14 }
    colon { return 15 }
    semi_colon { return 16 }
    bang { return 17 }
    at { return 18 }
    hash { return 19 }
    k_class { return 20 }
    k_and { return 21 }
    k_or { return 22 }
    k_else { return 23 }
    k_if { return 24 }
    k_for { return 25 }
    k_nil { return 26 }
    k_return { return 27 }
    k_while { return 28 }
    k_import { return 29 }
    k_true { return 30 }
    k_false { return 31 }
    k_def { return 32 }
    k_int { return 33 }
    k_float { return 34 }
    k_bool { return 35 }
    k_str { return 36 }
    identifier { return 37 }
    string { return 38 }
    v_int { return 39 }
    v_float { return 40 }

    from_str(in) {
        def kinds = [
            "(",
            ")",
            "[",
            "]",
            "{",
            "}",
            "<",
            ">",
            "=",
            "+",
            "-",
            "/",
            "*",
            ".",
            ",",
            ":",
            ";",
            "!",
            "@",
            "#",
            "class",
            "and",
            "or",
            "else",
            "if",
            "for",
            "nil",
            "return",
            "while",
            "import",
            "true",
            "false",
            "def",
            "int",
            "float",
            "bool",
            "str"
        ]
        def i = 0
        while i < #len(kinds) {
            if in == kinds[i] {
                return i
            }
            i = i + 1
        }
        return nil
    }
}

class Token(value, start, end, kind) {}

class Lexer(code, p) {

    whitespace {
        while @p < #len(@code) and @code[@p] == " " {
            @p = @p + 1
        }
    }

    is_done {
        return @p >= #len(@code)
    }

    letter() {
        if @is_done() {
            return false
        }
        def letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        def i = 0
        while i < #len(letters) {
            if letters[i] == @code[@p] {
                return true
            }
            i = i + 1
        }
        return false
    }

    digit() {
        if @is_done() {
            return false
        }
        def digits = "0123456789"
        def i = 0
        while i < #len(digits) {
            if digits[i] == @code[@p] {
                return true
            }
            i = i + 1
        }
        return false
    }

    advance {
        if @p < #len(@code) {
            @p = @p + 1
        }
    }

    identifier() {
        def start = @p
        def val = ""
        while @letter() {
            val = val + @code[@p]
            @p = @p + 1
        }
        def end = @p
        def keyword = Kind.from_str(val)
        if keyword != nil {
            return Token(val, start, end, keyword)
        }
        #print("here?")
        return Token(val, start, end, Kind().identifier())
    }

    number() {
        def start = @p
        def val = ""
        def is_float = false
        while @digit() or @code[@p] == "." {
            if @code[@p] == "." {
                is_float = true
            }
            val = val + @code[@p]
            @p = @p + 1
        }
        
        def end = @p
        if is_float {
            return Token(val, start, end, Kind.v_float())
        }
        return Token(val, start, end, Kind.v_int())
    }


    string() {
        def start = @p
        def val = "\""
        @p = @p + 1
        while @code[@p] != "\"" {
            val = val + @code[@p]
            @p = @p + 1
        }

        val = val + "\""
        @p = @p + 1
        def end = @p
        return Token(val, start, end, Kind.string())
    }

    single_char()  {
        def a = Kind.from_str(@code[@p])
        if a != nil {
            return Token(@code[@p], @p, @p+1, a)
        }
        return nil
    }

    next() {
        if @is_done() {
            return nil
        }
        @whitespace()

        while !@is_done() {
            if @letter() {
                return @identifier()
            }
            if @digit() {
                return @number()
            }
            def single_char = @single_char()
            if single_char != nil {
                @p = @p + 1
                return single_char
            }
            if @code[@p] == "\"" {
                return @string()
            }
            @advance()
        }
        return nil
    }
}

def input = #read_file("./src/sample.lum")
#print(input)

def lexer = Lexer(input, 0)


def done = false

while !done {
    #print("loop")
    def token = lexer.next()
    if token == nil {
        done = true
    }
    #print(token)
}

lexer.p = 0



