class Kind {
    left_paren int { return 0 }
    right_paren int { return 1 }
    left_bracket int { return 2 }
    right_bracket int { return 3 }
    left_brace int { return 4 }
    right_brace int { return 5 }
    less int { return 6 }
    greater int { return 7 }
    equal int { return 8 }
    plus int { return 9 }
    minus int { return 10 }
    slash int { return 11 }
    star int { return 12 }
    dot int { return 13 }
    comma int { return 14 }
    colon int { return 15 }
    semi_colon int { return 16 }
    bang int { return 17 }
    at int { return 18 }
    hash int { return 19 }
    k_class int { return 20 }
    k_and int { return 21 }
    k_or int { return 22 }
    k_else int { return 23 }
    k_if int { return 24 }
    k_for int { return 25 }
    k_nil int { return 26 }
    k_return int { return 27 }
    k_while int { return 28 }
    k_import int { return 29 }
    k_true int { return 30 }
    k_false int { return 31 }
    k_def int { return 32 }
    k_int int { return 33 }
    k_float int { return 34 }
    k_bool int { return 35 }
    k_str int { return 36 }
    identifier int { return 37 }
    string int { return 38 }
    v_int int { return 39 }
    v_float int { return 40 }

    from_str(str in) int {
        def kinds = [
            "(",
            ")",
            "[",
            "]",
            "{",
            "}",
            "<",
            ">",
            "=",
            "+",
            "-",
            "/",
            "*",
            ".",
            ",",
            ":",
            ";",
            "!",
            "@",
            "#",
            "class",
            "and",
            "or",
            "else",
            "if",
            "for",
            "nil",
            "return",
            "while",
            "import",
            "true",
            "false",
            "def",
            "int",
            "float",
            "bool",
            "str"
        ]<str>
        def i = 0
        while i < #len(kinds) {
            if in == kinds[i] {
                return i
            }
            i = i + 1
        }
        return nil
    }
}

class Token(str value, int start, int end, int kind) {}

class Lexer(str code, int p) {

    whitespace() {
        while @p < #len(@code) and @code[@p] == " " {
            @p = @p + 1
        }
    }

    is_done bool {
        return @p >= #len(@code)
    }

    letter() bool {
        if @is_done() {
            return false
        }
        def letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        def i = 0
        while i < #len(letters) {
            if letters[i] == @code[@p] {
                return true
            }
            i = i + 1
        }
        return false
    }

    digit() bool {
        if @is_done() {
            return false
        }
        def digits = "0123456789"
        def i = 0
        while i < #len(digits) {
            if digits[i] == @code[@p] {
                return true
            }
            i = i + 1
        }
        return false
    }

    advance {
        if @p < #len(@code) {
            @p = @p + 1
        }
    }

    identifier() Token {
        def start = @p
        def val = ""
        while @letter() {
            val = val + @code[@p]
            @p = @p + 1
        }
        def end = @p
        def keyword = Kind.from_str(val)
        if keyword != nil {
            return Token(val, start, end, keyword)
        }
        return Token(val, start, end, Kind.identifier)
    }

    number() Token {
        def start = @p
        def val = ""
        def is_float = false
        while @digit() or @code[@p] == "." {
            if @code[@p] == "." {
                is_float = true
            }
            val = val + @code[@p]
            @p = @p + 1
        }
        
        def end = @p
        if is_float {
            return Token(val, start, end, Kind.v_float)
        }
        return Token(val, start, end, Kind.v_int)
    }


    string() Token {
        def start = @p
        def val = "\""
        @p = @p + 1
        while @code[@p] != "\"" {
            val = val + @code[@p]
            @p = @p + 1
        }

        val = val + "\""
        @p = @p + 1
        def end = @p
        return Token(val, start, end, Kind.string)
    }

    single_char() Token {
        def a = Kind.from_str(@code[@p])
        if a != nil {
            return Token(@code[@p], @p, @p+1, a)
        }
        return nil
    }

    next Token {
        def test = @is_done()
        if test {
            return nil
        }
        @whitespace()

        while !@is_done() {
            if @letter() {
                return @identifier()
            }
            if @digit() {
                return @number()
            }
            def single_char = @single_char()
            if single_char != nil {
                @p = @p + 1
                return single_char
            }
            if @code[@p] == "\"" {
                return @string()
            }
            @advance()
        }
        return nil
    }


}

def input = #read_file("./src/sample.lum")
#print(input)

def lexer = Lexer(input, 0)

def done = false

while !done {
    def token = lexer.next
    if token == nil {
        done = true
    }
    #print(token)
}

